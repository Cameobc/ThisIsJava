#상속(Inheritance)
------------
1. 상속
    - 코드의 중복을 줄여준다.
    - private 접근 제한자를 갖는 필드와 메소드는 상속 대상에서 제외된다.
    - 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.
    - 다중 상속을 허용하지 않는다.
    - 부모 객체가 먼저 생성된 후 자식 객체가 생성된다.
    - 모든 객체는 클래스의 생성자를 호출해야만 생성된다.
    - 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.
    - 명시적으로 선언되지 않았을 경우 컴파일러는 기본 생성자 super(); 를 생성해 낸다.
    - super();  부모의 기본 생성자를 호출하며, 명시적으로 호출하고 싶다면 매개변수를 같이 작성하면 된다.
    
   > 메소드 재정의(@Override)
   >  - 부모 클래스의 메소드를 자식 클래스에서 사용하기 적합하지 않은 경우, 메소드 오버라이딩을 통해 수정하여 사용한다.
   >  - 메소드 오버라이딩을 한 경우, 부모 객체의 메소드는 숨겨지고 자식 객체의 오버라이딩 된 메소드가 호출된다.
   > > - 부모의 메소드와 동일한 시그너쳐(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 함
   > > - 접근 제한을 더 강하게 오버라이딩 할 수는 없음
   > > - 새로운 예외(Exception) 를 throws 할 수 없음
   > - 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면, 명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있음
   


------------
2. final  클래스
   - 클래스, 필드, 메소드 선언 시에 사용할 수 있으며 해당 선언이 최종 상태이고 결코 수정될 수 없음을 뜻함
   - 클래스에 final 을 붙일 경우 상속할 수 없는 클래스가 된다.
   - cf) 대표적인 예가 String  클래스이다.
   - 메소드를 선언할 때 final 을 붙이면 오버라이딩이 불가능한 메소드가 된다.


------------
3. protected 접근 제헌자
   - 같은 패키지에서는 default 와 같이 접근 제한이 없지만, 다른 패키지에서는 자식 클래스의 접근만 허용함.
   - 상속 받았을 경우 다른 패키지에서도 필드/메소드/생성자에 접근 가능하지만, new 연산자는 사용 불가능하다.

------------
4. 타입 변환과 다형성
   - 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줌
   - 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용 -> 부모 타입에 모든 자식 객체가 대입될 수 있다.
   > - 자동타입변환(Promotion)
   >  - 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 의미
   >  - 개념은 자식이 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것이다.
   >  - 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능함
   >  - 변수가 자식 객체를 참조하더라도 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다.
   >  - 예외!! 메소드가 자식 클래스에서 오버라이딩되었다면, 자식 클래스의 메소드가 대신 호출된다.(다형성(Polymorphism)과 관련있는 매우 중요한 성질)
------------
5. 필드의 다형성
   - 다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 의미
   - 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 겨로가가 달라질 수 있는 것을 필드의 다형성이라 함.
------------
6. 매개 변수의 다형성
   - 메소드를 호출할 때에는 매개 변수의 타입과 동일한 매개값으 지정하는 것이 정석이지만, 매개값을 다양화하기 위해 매개 변수에 자식 타입 객체를 지정할 수도 있다.
   - 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.
   - 자식 객체가 부모의 메소드를 오버라이딩 했다면 메소드 내부에서 오버라이딩된 메소드를 호출함으로써 메소드의 실행 결과는 다양해진다.
------------
7. 강제 타입 변환(Casting)
   - 부모 타입을 자식 타입으로 변환하는 것을 의미
   - 모든 부모 타입을 자식 클래스 타입으로 강제 형변환 가능한 것은 아님
   - 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있음
   > 자식클래스 변수 - (자식클래스) 부모 클래스 타입;
   >  - 자식 타입에 선언된 피륻와 메소드를 꼭 사용해야 할 때 이러한 강제 타입 변환을 통해 자식 타입의 필드와 메서드를 사용할 수 있다.
------------
8. 객체 타입 확인(instanceof)
   - 강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하기 때문에 부모 타입의 변수가 부모 객체를 참조할 경우 자식 타입으로 변환할 수 없음
   - 어떤 객체가 어떤 클래스의 인스턴스인지 확인하기 위해 instanceof 연산자 사용 가능
   - 좌항은 객체가 오고, 우항은 타입이 오는데 좌항의 객체가 우항의 인스턴스 타입으로 생성되면 true, 그렇지 않으면 false 리턴
   > boolean result = (객체) instanceof (타입)
   - 매개값의 타입을 조사할 때 주로 사용되며, 메소드 내에서 강제 타입 변환이 필요한 경우 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인 후 안전하게 강제 타입 변환을 해야 한다.
------------
9. 추상 클래스(Abstract Class)
   - 사전적 의미로 추상(abstract)은 실체 간에 공통되는 특성을 추출한 것을 의미
   - 객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 하고, 실체 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스라고 함
   - 추상 클래스와 실체 클래스는 상속 관계를 지님
   - 추상 클래스가 부모이며, 실체 클래스가 자식으로 구현되어 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성(필드&메소드)를 가질 수 있음
   - 추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 직접 객체를 생성해서 사용할 수 없다. 즉, 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용된다.
   
   > - 추상 클래스의 용도
   > 1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적
   > 2. 실체 클래스를 작성할 때 시간을 절약하기 위함
   
   - 추상 클래스를 선언할 때는 클래스 선언에 abstract 키워드를 붙여야 함
   - new 연산자를 통해 직접 생성자를 호출할 수는 없지만, 자식 객체가 생성될 때 super 를 호출하여 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 함
   
   > - 추상 메소드와 오버라이딩
   > > - 실체 클래스의 멤버(필드, 메소드)를 통일화하는데 목적이 있지만, 메소드 선언만 통일하고 실행 내용은 달라야 하는 경우 추상 메소드를 선언한다.
   > > - 추상 메소드는 추상 클래스에서만 선언 가능하며 메소드의 선언부만 있고, 실행 내용인 중괄호가 없는 메소드를 의미
   > > - 자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 하며, 그렇지 않을 경우 컴파일 에러가 발생한다.