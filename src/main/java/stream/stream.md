#스트림과 병렬처리(Stream)

------------
1. 스트림
    - 자바 8부터 추가된 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 반복자이다.
    - 1-1. 람다식으로 요소 처리 코드 제공
      - Stream 이 처리하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개 타입을 가지기 때문에 람다식 또는 메소드참조를 이용해서 요소 처리 내용을 매개값으로 전달할 수 있다.
    - 1-2. 내부 반복자를 사용하므로 병렬 처리가 쉽다.
      - 내부 반복자란 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야 할 코드만 제공하는 코드 패턴을 말함
      - 외부 반복자는 for, iterator 문을 이용하는 while 문을 의미함
      - 내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 병렬 작업을 할 수 있게 도와주기 때문에 순차적 외부 반복자보다 효율적으로 요소를 반복시킬 수 있다
      - 또한, 개발자가 요소 처리 코드에만 집중할 수 있도록 만든다.
      - 스트림을 사용하면 코드도 간결해지미만 무엇보다도 요소의 병렬 처리가 컬렉션 내부에서 처리되므로 일석이조의 효과를 가져온다.
      - 병렬(parallel) 처리란 한 가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하는 것을 말한다.
    - 1-3. 중간 처리와 최종 처리를 할 수 있다.
      - 스트림은 컬렉션의 요소에 대해 중간 처리와 최종 처리를 수행할 수 있는데, 중간 처리에서는 매핑, 필터링, 정렬을 수행하고 최종 처리에서는 반복, 카운팅, 편균, 총합 등의 집계 처리를 수행한다.

---
2. 스트림의 종류
   - BaseStream 인터페이스에는 모든 스트림에서 사용할 수 있는 공통 메소드들이 정의되어 있음
   - Stream 은 객체를 처리하는 스트림이고, IntStream, DoubleStream, LongStream 은 각각 기본 타입인 int, double, long 요소를 처리하는 스트림이다.

---
3. 스트림 파이프라인
   - 대량의 데이터를 가공해서 축소하는 것을 일반적으로 리덕션(Reduction) 이라고 하는데, 데이터의 합계, 평균값, 카운팅, 최대값, 최소값 등이 대표적인 리덕션의 결과물이라고 할 수 있다.
   - 스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 함께 합계, 평균, 카운팅, 최대값, 최소값 등의 최종 처리를 파이프라인으로 해겨랗ㅁ
   - 파이프라인은 여러 개의 스트림이 연결되어 있는 구조를 말하며 최종 처리를 제외하고는 모두 중간 처리 스트림이다.
   - 중간 스트림이 생성될 때 요소들이 바로 중간 처리되는 것이 아니라 최종 처리가 시작되기 전까지 중간 처리는 지연되며, 최종 처리가 시작되면 비로소 컬렉션의 요소가 하나씩 중간 스트림에서 처리되고 최종 처리까지 오게 된다.
   - 메소드들은 중간 처리된 스트림을 리턴하고, 이 스트림에서 다시 중간 처리 메소드를 호출해서 파이프라인을 형성하게 된다.
   - 리턴 타입이 스트림이라면 중간 처리 메소드이고, 기본 타입이거나 Optional~ 이라면 최종 처리 메소드이다.

---
4. 필터링(distinct(), filter())
   - 중간 처리 기능으로 요소를 걸러내는 역할을 하며, distinct(), filter() 메소드는 모든 스트림이 가지고 있는 공통 메소드이다.

---
5. 매핑(flatMapXXX(), mapXXX(), asXXXStream(), boxed())
   - 매핑은 중간 처리 기능으로 스트림의 요소를 다른 요소로 대체하는 작업을 말한다.
   - 5-1. flatMapXXX()
     - 요소를 대체하는 복수 개의 요소들로 구성된 새로운 스트림을 리턴함
   - 5-2. mapXXX()
     - 요소를 대체하는 요소로 구성된 새로운 스트림을 리턴함.
   - 5-3. asDoubleStream(), asLongStream(), boxed()
      - asDoubleStream() 메소드는 int 요소 또는 long 요소를 double 요소로 타입 변환하여 DoubleStream 생성
      - asLongStream() 메소드는 int 요소를 long 요소로 타입 변환하여 LongStream 생성
      - boxed() 메소드는 int, long, double 요소를 Integer, Long, Double 로 박싱해서 Stream 생성

---
6. 정렬(sorted())
   - 스트림은 요소가 최종 처리되기 전에 중간 단계에서 요소를 정렬하여 최종 처리 순서를 변경할 수 있다.
   - 객체 요소일 경우 클래스가 Comparanble 을 구현하지 않으면 메소드 호출 시 ClassCastException 이 발생함

---
7. 루핑(peek(), forEach())
   - 루핑(looping) 은 요소 전체를 반복하는 것을 말함
   - peek() 는 중간 처리 메소드이므로 최종 처리 메소드가 실행되지 않으면 지연되어 동작하지 않는다.
   - forEach() 는 요소를 소비하는 최종 처리 메소드이므로 이후에 다른 최종 메소드를 호출하면 안된다.

---
8. 매칭(allMatch(), anyMatch(), noneMatch())
   - allMatch() : 메소드의 모든 요소들이 매개값으로 주어진 Predicate 의 조건을 만족하는지 조사
   - anyMatch() : 메소드의 최소 한 개의 요소가 매개값으로 주어진 Predicate 의 조건을 만족하는지 조사
   - noneMatch() : 메소드의 모든 요소들이 매개값으로 주어진 Predicate 의 조건을 만족하지 않는지 조사

---
9. 기본 집계(sum(), count(), average(), max(), min())
   - 집계(Aggregate) 는 최종 처리 기능으로 요소들을 처리해서 카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 하나의 값으로 산출하는 것을 말한다.
   - 집계는 대량의 데이터를 가공해서 축소하는 리덕션(Reduction) 이라고 할 수 있다.
   - 9-1. Optional 클래스
     - 단순히 집계 값만 저장하는 것이 아니라, 집계 값이 존재하지 않을 경우 디폴트 값을 설정할 수도 있고, 집계 값을 처리하는 Consumer 도 등록할 수 있다.
     - 요소가 없을 경우 NoSuchElementException 예외가 발생하며 이를 피하는 세 가지 방법이 존재함.
       1. Optional 객체를 얻어 isPresent() 메소드로 평균값 여부를 확인
       2. orElse() 메소드로 디폴트 값을 정해 놓으면 평균값을 구할 수 없는 경우 orElse()의 매개값이 디폴트 값이 된다.
       3. ifPresent() 메소드로 평균값이 있을 때만 값을 이요하는 람다식을 실행함

---
10. 커스텀 집계(reduce() )
    - 다양한 집계 결과물을 만들 수 있도록 reduce() 메소드를 제공함
    - 각 인터페이스에는 매개 타입으로 XXXOperator, 리턴 타입으로 OptionalXXX 을 가지는 reduce() 메서드가 오버로딩 되어 있다.
    - 스트림 요소가 전현 없을 경우 디폴트값인 identity 매개값이 리턴된다.

---
11. 수집(collect())
    - 요소들을 필터링 또는 매핑한 후 요소들을 수집하는 최종 처리 메소드인 collect()  을 제공
    - 필요한 요소만 컬렉션으로 담을 수 있고, 요소들을 그룹핑한 후 집계(리덕션)할 수 있다.
      - collect(Collector<T, A, R) collector)
      - T는 요소이고, A는 누적기, R은 요소가 저장될 컬렉션임
      - 즉, T 요소를 A 누적기가 R에 저장한다는 의미
    - 11-1. 사용자 정의 컨테이너에 추가하기
      - 스트림은 요소들을 필터링 또는 매핑하여 사용자 정의 컨테이너 객체에 수집할 수 있도록 collect() 메소드를 추가적으로 제공함
        > collect(Supplier<R>, BiConsumer<R.? super T>, BiConsumer<R,R>)
        - 첫 번째 Supplier 요소들이 수집될 컨테이너 객체(R)을 생성하는 역할을 함
          - 순차 처리 스트림에서는 단 한 번 Supplier 가 실행되고 하나의 컨테이너 객체를 생성
          - 병렬 처리 스트림에서는 여러 번 SUpplier 가 실행되고 스레드별로 여러 개의 컨테이너 객체를 생성하며, 최종적으로 하나의 컨테이너 객체로 결합된다.
        - 두 전째 XXXConsumer 는 컨테이너 객체(R)에 요소(T)를 수집하는 역할을 하며 스트림에서 요소를 수집할 때마다 실행
        - 세 번째 BiConsumer 는 컨테이너 객체(R) 를 결합하는 역할을 한다. 순차 처리 스트림에서는 호출되지 않고, 병렬 처리 스트림에서만 호출되어 스레드별로 새성된 컨테이너 객체를 결합해서 최종 컨테이너 객체를 완성
      - 순차 처리 스트림에서는 리턴 객체가 첫번째 Supplier 가 생성한 객체지만, 병렬 처리 스트림에서는 최종 결합된 컨테이너 객체가 된다.
    - 11-2. 요소를 그룹핑해서 수집
      - groupingBy() 는 스레드에 안전하지 않은 Map 을 생성하고, groupingByConcurrent() 는 스레드에 안전한 ConcurrentMap 을 생성함
    - 11-3. 그룹핑 후 매핑 집계
      - Collectors.groupingBy() 메소드는 그룹핑 후 매핑이나 집계를 할 수 있도록 두 번째 매개값으로 Collector 를 가질 수 있음

---
12. 병렬 처리(Parallel Operation)
 - 병렬 처리란 멀티 코어 CPU 환경에서 하나의 작업을 분할해서 각각의 코어가 병렬적으로 처리하는 것을 말하며 작업 처리 시간을 줄이기 위해 사용
 - 자바 8부터 병렬 스트림 제공
   - 12-1. 동시성(Concurrency) & 병렬성"(Parallelism)
     - 동시성은 멀티 작업을 위해 멀티 스레드가 번갈아가며 실행하는 성질
     - 병렬성은 멀티 작업을 위해 멀티 코어를 이용해서 동시에 실행하는 성질
     - 싱글 코어 CPU 를 이용한 멀티 작업은 병렬적으로 실행되는 것처럼 보이지만 사실을 동시성 작업임
     - 병렬성은 데이터 병셜성과 작업 병렬성으로 구분 가능
       - 데이터 병렬성(Data Parallelism)
         - 전체 데이터를 쪼개어 서브 데이터들로 만들고 이 서브 데이터들을 병렬 처리해서 작업을 빨리 끝내는 것을 의미
         - 병렬 스트림은 데이터 병렬성을 구현
         - 멀티 코어 수만큼 대용량 요소를 서브 요소들로 나누고, 각각의 서브 요소들을 분리된 스레드에서 병렬 처리시킴
       - 작업 병렬성(Task Parallelism)
         - 서로 다른 작업을 병렬 처리하는 것을 말함
         - 대표적인 예로 웹 서버가 있다.(각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리)
   - 12-2. 포크조인(ForkJoin) 프레임워크
     - 병렬 스트림은 요소들을 병렬 처리하기 위해 포크조인 프레임워크를 사용함
     - 포크 단계에서는 전체 데이터를 서브 데이터로 분리
     - 서브 데이터를 멀티 코어에서 병렬로 처리함
     - 조인 단계에서 서브 결과를 결합해서 최종 결과를 만들어 낸다.
   
   - 12-3. 병렬 스트림 생성
     - 병렬 처리를 위해 코드에서 포크조인 프레임워크를 직접 사용할 수는 있지만, 병렬 스트림을 이용할 경우에는 백그라운드에서 포크조인 프레임워크가 사용되기 때문에 개발자는 매우 쉽게 병렬 처리를 할 수 있다.
     - parallelStream()
       - 컬렉션으로부터 병렬 스트림을 바로 리턴함
     - parallel()
       - 순차 처리 스트림을 병렬 스트림으로 변환해서 리턴함
   - 12-4. 병렬 처리 성능
     - 요소의 수와 요소당 처리 시간
       - 컬렉션에 요소의 수가 적고 요소당 처리 시간이 짧으면 순차 처리가 오히려 병렬 처리보다 빠를 수 있다. 병렬 처리는 스레드풀 생성, 스레드 생성이라는 추가 비용이 발생하기 때문
     - 스트림 소스의 종류
       - ArrayList, 배열은 인덱스로 요소를 관리하기 때문에 포그 단계에서 요소를 쉽게 분리할 수 있어 병렬 처리 시간이 절약된다.
       - HashSet, TreeSet 은 요소 분리가 쉽지 않고, LinkedList 역시 링크를 따라가야 하므로 요소 분리가 쉽지 않음
     - 코어의 수
       - 싱글 코어 CPU일 경우 순차 처리가 빠르다.