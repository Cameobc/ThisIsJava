#컬렉션 프레임워크(Collection Framework)

------------
1. 컬렉션 프레임워크 소개
    - 컬렌션의 사전적 의미는 요소를 수집해서 저장하는 것이며 자바 컬렉션은 객체를 수집하여 저장하는 역할을 한다.
    - List, Set, Map 이 있다.
    - List 와 Set 은 객체를 추가, 삭제, 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드만 모아 Collection 인터페이스로 정의해두고 있다.

| 인터페이스 분류   |  | 특징                                 | 구현 클래스                                      |
|------------|-----|------------------------------------|---------------------------------------------|
| Collection | List | - 순서를 유지하고 저장<br/> - 중복 저장 가능      | ArrayList, Vector, <br/>LinkedList          |
| Collection | Set | - 순서를 유지하지 않고 저장 <br/> - 중복 저장 안 됨 | HashSet, TreeSet                            |                   |
| Map        |  | - 키와 값의 쌍으로 저장<br/> - 키는 중복 저장 안 됨 | HashMap, Hashtable,<br/>TreeMap, Properties| |            

---
2. List 컬렉션
    - 객체를 일렬로 늘어놓은 구조를 가지고 있으며, 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공함
    - 객체의 번지를 참조하며, 동일한 객체를 중복 저장할 경우 동일한 번지가 참조된다.
    - null 저장이 가능하지만 이 경우 해당 인덱스는 객체를 참조하지 않는다
   
    - 2-1. ArrayList
      - ArrayList 에 객체를 추가하면 객체가 인덱스로 관리된다.배열과 달리 저장 용량(capacity)을 초과한 객체들이 들어오면 자동적으로 저장 용량이 늘어난다.
      - 10 개의 객체를 저장할 수 있는 초기용량을 가지고, 처음부터 용량을 크게 잡고 싶다면 용량의 크기를 매개값으로 받는 생성자를 이용하면 된다.
      - 타입 파라미터를 이용하여 저장할 객체의 타입을 지정할 수 있다.
      - ArrayList 에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨지며, 특정 인덱스에 객체를 삽입하면 1씩 인덱스가 밀려난다.
      - 따라서, 빈번한 객체 삭제와 삽입이 일어나는 곳에서는 LinkedList 를 사용하는 것이 좋다.
      - 인덱스 검색이나 맨 마지막에 객체를 추가하는 경우 좋은 성능을 발휘한다.
    
    - 2-2. Vector
      - ArrayList 와 동일한 내부 구조를 지니고 있으며, Vector 를 생성하기 위해서는 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다.
      - > List<E> list = new Vector<E>();
      - Vector 는 동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실핼할 수 있다.
      - 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있으며 이를 스레드가 안전(Thread Safe) 하다라고 말한다.

    - 2.3 LinkedList
      - ArrayList 와 사용 방법은 똑같지만 내부 구조가 다름
      - 인접 참조를 링크해서 체인처럼 관리한다.
      - 특정 인덱스의 객체를 제거하거나 삽입할 경우 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다.
      - 처음 생성될 때는 어떤 링크도 만들어지지 않기 떄문에 내부는 비어있다고 보면 된다.
      
        | 구분 | 순차적으로 추가/삭제 | 중간에 추가/삭제 | 검색  |
        |------------|-----------|-----|------------|
        | ArrayList | 빠르다  | 느리다 | 느리다 |
        | LinkedList | 느리다  | 빠르다 | 빠르다 |            

---
3. Set 컬렉션
   - 저장 순서가 유지되지 않으며, 객체를 중복해서 저장할 수 없고, 하나의 null 만 저장할 수 있다.
   - 인덱스로 객체를 검색해서 가져오는 메소드가 없는 대신 전체 객체를 대상으로 한 번씩 반복해서 가져오는 반복자(Iterator) 를 제공함
   - Iterator 에서 하나의 객체를 가져올 때는 next() 메소드를 사용하며, next() 사용 전에 객체가 있는지 확인하는 것이 좋다.
   - 3-1. HashSet
     - 객체들을 순서없이 저장하고 중복을 허용하지 않는다.
     - HashSet  이 판단하는 동일한 객체가 꼭 같은 인스턴스를 뜻하지는 않는다.
     - 객체를 저장하기 전 먼저 객체의 hashCode() 를 호출해서 해시코드를 알아내고, 이미 저장된 객체들의 해쉬코드와 비교한다.
     - 만약 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교해서 true 가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.
     
---
4. Map 컬렉션
    - key 와 value 로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.
    - 키와 값은 모두 객체이며, 키는 중복저장할 수 없지만 값은 중복저장할 수 있다.
    - 만약 기존 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 사라지고, 새로운 값으로 대치된다.
    - 저장된 전체 객체를 대상으로 키를 하나씩 얻고 싶을 때면
        1. ketSet() 메소드로 모든 키를 Set 컬렉션으로 얻은 다음, 반복자를 통해 키를 하나씩 얻고, get() 메소드를 통해 값을 얻는다
        2. entrySet() 메소드로 모든 Map.Entry 를 Set 컬렉션으로 얻은 다음, 반복자를 통해 Map.Entry 를 하나씩 얻고, getKey() 와 getValue() 메소드를 이용해 키와 값을 얻는다.
    
    - 4-1. HashMap
      - hashCode() 와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다.
      - 즉 동일한 키가 될 조건은 hashCode() 의 리턴값이 같아야 하고, equals() 메소드가 true 를 리턴해야 한다.
      - 키와 값의 타입은 기본 타입(byte, short, int float, double, boolean, char) 을 사용할 수 없고, 인터페이스 및 클래스 타입만 사용 가능하다.
      
    - 4-2. HashTable
      - HashMap 과 동일한 내부 구조를 가지고 있다.
      - hashCode() 와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 함
      - HashMap 과의 차이점은 HashTable은 동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소듣들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.
      - 멀티 스레드 환경에서 객체를 안전하게 추가/삭제할 수 있으며 이를 스레드가 안전(thread safe) 하다고 말한다.

    - 4-3. Properties
      - Hashtable 의 하위 클래스이기 때문에 Hashtable 의 모든 특징을 그대로 가지고 있다.
      - 차이점은 Hashtable 은 키와 값을 다양한 타입으로 지정이 가능한데 반해 Properties 는 키와 값을 String 타입으로 제한한 컬렉션이다.
      - 프로퍼티 파일은 키와 값이 = 로 연결되어 있는 텍스트 파일로 ISO 8859-1 문자셋으로 저장되며, 표현할 수 없는 한글은 유니코드로 변환되어 저장한다.
      - 