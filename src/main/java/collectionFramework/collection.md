#컬렉션 프레임워크(Collection Framework)

------------
1. 컬렉션 프레임워크 소개
    - 컬렌션의 사전적 의미는 요소를 수집해서 저장하는 것이며 자바 컬렉션은 객체를 수집하여 저장하는 역할을 한다.
    - List, Set, Map 이 있다.
    - List 와 Set 은 객체를 추가, 삭제, 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드만 모아 Collection 인터페이스로 정의해두고 있다.

| 인터페이스 분류   |  | 특징                                 | 구현 클래스                                      |
|------------|-----|------------------------------------|---------------------------------------------|
| Collection | List | - 순서를 유지하고 저장<br/> - 중복 저장 가능      | ArrayList, Vector, <br/>LinkedList          |
| Collection | Set | - 순서를 유지하지 않고 저장 <br/> - 중복 저장 안 됨 | HashSet, TreeSet                            |                   |
| Map        |  | - 키와 값의 쌍으로 저장<br/> - 키는 중복 저장 안 됨 | HashMap, Hashtable,<br/>TreeMap, Properties| |            

---
2. List 컬렉션
    - 객체를 일렬로 늘어놓은 구조를 가지고 있으며, 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공함
    - 객체의 번지를 참조하며, 동일한 객체를 중복 저장할 경우 동일한 번지가 참조된다.
    - null 저장이 가능하지만 이 경우 해당 인덱스는 객체를 참조하지 않는다
   
    - 2-1. ArrayList
      - ArrayList 에 객체를 추가하면 객체가 인덱스로 관리된다.배열과 달리 저장 용량(capacity)을 초과한 객체들이 들어오면 자동적으로 저장 용량이 늘어난다.
      - 10 개의 객체를 저장할 수 있는 초기용량을 가지고, 처음부터 용량을 크게 잡고 싶다면 용량의 크기를 매개값으로 받는 생성자를 이용하면 된다.
      - 타입 파라미터를 이용하여 저장할 객체의 타입을 지정할 수 있다.
      - ArrayList 에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨지며, 특정 인덱스에 객체를 삽입하면 1씩 인덱스가 밀려난다.
      - 따라서, 빈번한 객체 삭제와 삽입이 일어나는 곳에서는 LinkedList 를 사용하는 것이 좋다.
      - 인덱스 검색이나 맨 마지막에 객체를 추가하는 경우 좋은 성능을 발휘한다.
    
    - 2-2. Vector
      - ArrayList 와 동일한 내부 구조를 지니고 있으며, Vector 를 생성하기 위해서는 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다.
      - > List<E> list = new Vector<E>();
      - Vector 는 동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실핼할 수 있다.
      - 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있으며 이를 스레드가 안전(Thread Safe) 하다라고 말한다.

    - 2.3 LinkedList
      - ArrayList 와 사용 방법은 똑같지만 내부 구조가 다름
      - 인접 참조를 링크해서 체인처럼 관리한다.
      - 특정 인덱스의 객체를 제거하거나 삽입할 경우 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다.
      - 처음 생성될 때는 어떤 링크도 만들어지지 않기 떄문에 내부는 비어있다고 보면 된다.
      
        | 구분 | 순차적으로 추가/삭제 | 중간에 추가/삭제 | 검색  |
        |------------|-----------|-----|------------|
        | ArrayList | 빠르다  | 느리다 | 느리다 |
        | LinkedList | 느리다  | 빠르다 | 빠르다 |            

---
3. Set 컬렉션
   - 저장 순서가 유지되지 않으며, 객체를 중복해서 저장할 수 없고, 하나의 null 만 저장할 수 있다.
   - 인덱스로 객체를 검색해서 가져오는 메소드가 없는 대신 전체 객체를 대상으로 한 번씩 반복해서 가져오는 반복자(Iterator) 를 제공함
   - Iterator 에서 하나의 객체를 가져올 때는 next() 메소드를 사용하며, next() 사용 전에 객체가 있는지 확인하는 것이 좋다.
   - 3-1. HashSet
     - 객체들을 순서없이 저장하고 중복을 허용하지 않는다.
     - HashSet  이 판단하는 동일한 객체가 꼭 같은 인스턴스를 뜻하지는 않는다.
     - 객체를 저장하기 전 먼저 객체의 hashCode() 를 호출해서 해시코드를 알아내고, 이미 저장된 객체들의 해쉬코드와 비교한다.
     - 만약 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교해서 true 가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.
     
---
4. Map 컬렉션
    - key 와 value 로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.
    - 키와 값은 모두 객체이며, 키는 중복저장할 수 없지만 값은 중복저장할 수 있다.
    - 만약 기존 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 사라지고, 새로운 값으로 대치된다.
    - 저장된 전체 객체를 대상으로 키를 하나씩 얻고 싶을 때면
        1. ketSet() 메소드로 모든 키를 Set 컬렉션으로 얻은 다음, 반복자를 통해 키를 하나씩 얻고, get() 메소드를 통해 값을 얻는다
        2. entrySet() 메소드로 모든 Map.Entry 를 Set 컬렉션으로 얻은 다음, 반복자를 통해 Map.Entry 를 하나씩 얻고, getKey() 와 getValue() 메소드를 이용해 키와 값을 얻는다.
    
    - 4-1. HashMap
      - hashCode() 와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다.
      - 즉 동일한 키가 될 조건은 hashCode() 의 리턴값이 같아야 하고, equals() 메소드가 true 를 리턴해야 한다.
      - 키와 값의 타입은 기본 타입(byte, short, int float, double, boolean, char) 을 사용할 수 없고, 인터페이스 및 클래스 타입만 사용 가능하다.
      
    - 4-2. HashTable
      - HashMap 과 동일한 내부 구조를 가지고 있다.
      - hashCode() 와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 함
      - HashMap 과의 차이점은 HashTable은 동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소듣들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.
      - 멀티 스레드 환경에서 객체를 안전하게 추가/삭제할 수 있으며 이를 스레드가 안전(thread safe) 하다고 말한다.

    - 4-3. Properties
      - Hashtable 의 하위 클래스이기 때문에 Hashtable 의 모든 특징을 그대로 가지고 있다.
      - 차이점은 Hashtable 은 키와 값을 다양한 타입으로 지정이 가능한데 반해 Properties 는 키와 값을 String 타입으로 제한한 컬렉션이다.
      - 프로퍼티 파일은 키와 값이 = 로 연결되어 있는 텍스트 파일로 ISO 8859-1 문자셋으로 저장되며, 표현할 수 없는 한글은 유니코드로 변환되어 저장한다.

---
5. 검색 기능을 강화시킨 걸렉션
   - TreeSet, TreeMap 제공
   - 이진 트리를 이용해서 계층적 구조를 가지면서 객체를 저장함
   - 5-1. 이진 트리 구조
     - 여러 개의 노드가 트리 형태로 연결된 구조로 루트 노드라고 불리는 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있음
     - 위아래로 연결된 두 노드를 부모 자식 관계에 있다고 칭함
     - 하나의 부모 노드는 최대 두 개의 자식 노드와 연결 가능
     - 작은 값은 왼쪽에, 큰 값은 오른쪽에 저장
     - 왼쪽 마지막 노드가 제일 작은 값이 되고, 오른쪽 마지막 노드가 가장 큰 값이 된다.
   - 5-2. TreeSet
     - 이진 트리를 기반으로 한 Set 컬렉션
     - 하나의 노드값이 value 와 왼쪽과 오른쪽 자식 노드를 참조하기 위한 두 개의 변수로 구성
     - 객체 저장 시에 자동으로 정렬되며, 부모보다 낮은 것을 왼쪽에 높은 것을 오른쪽 자식 노드에 저장함
     - 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해 씀
   - 5-3. TreeMap
     - 이진 트리를 기반으로 한 Map 컬렉션
     - 키와 값이 저장된 Map.Entry 객체를 저장
     - 자동 정렬되며 부모 키 값과 비고하여 낮은 것을 왼쪽 자식 노드에 높은 것을 오른쪽 자식 노드에 저장함.
     - 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해 씀
   - 5-4. Comparable & Comparator
     - TreeSet & TreeMap 의 키는 자동으로 오름 차순 저장하는데 숫자 타입의 경우는 값으로 저장하고, 문자열인 경우 유니코드로 정렬한다.
     - 정렬을 위해 java.lang.Comparable을 구현한 객체를 요구
     - Comparable 에는 compareTo() 메소드가 저으이되어 있기 때문에 사용자 정의 클래스에서는 이 메소드를 오버라이딩하여 사용
     - TreeSet & TreeMap 생성자의 매개값으로 정렬자를 제공하면 Comparable 비구현 객체도 정렬시킬 수 있다.

---
6. LIFO(Last In First Out) 와 FIFO(First In First Out) 컬렉션
    - 컬렉션 프로엠워크에서는 LIFO 자료구조를 제공하는 스택과 FIFO 자료구조를 제공하는 큐 인터페이스를 제공하고 있음
    - 스택을 응용한 대표적인 예가 JVM 스택 메모리이며, 큐를 응용한 대표적인 예는 스레드풀의 작업 큐이다.
    - 6-1. Stack
      - LIFO 자료구조를 구현한 클래스 
      - 주요 메소드 : push(), peek(), pop()
    - 6-2. Queue
      - FIFO 자료구조를 구현한 클래스
      - 주요 메소드 : offer(), peek(), poll()

---
7. 동기화된 컬렉션
    - 컬렉션 프레임워크의 대부분의 클래스들은 싱글 스레드 환경에서 사용할 수 있도록 설계되었다. 그렇기 때문에 여러 스레드가 동시에 컬렉션에 접근한다면 의도치않게 요소가 변경될 수 있는 불안전한 상태가 된다
    - Vector 와 Hashtable 은 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드 환경에서 안전하게 요소를 처리할 수 있지만, ArrayList, HashSet, HashMap 은 멀티 스레드 환경에서 안전하지 않다.
    - 컬렉션 프레임워크는 비동기화된 메소드를 동기호된 메소드로 래핑하는 Collections 의  synchronizedXXX() 메소드를 제공하고 있다.
    - 매개값으로 비동기화된 컬렉션을 대입하면 동기화된 컬렉션을 리턴한다.

---
8. 병렬 처리를 위한 컬렉션
    - 동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만 전체 요소를 빠르게 처리하지는 못한다.
    - 하나의 스레드가 처리중일 때 전체 잠금이 발생하여, 다른 스레드가 대기 상태가 되기 때문이다. 이 때문에 멀티 스레드가 병렬적으로 컬렉션의 요소들을 처리할 수 없다.
    - 자바는 멀티 스레드가 컬렉션의 요소들을 병렬적으로 처리할 수 있도록 특별한 컬렉션을 제공하고 있는데 ConcurrentHashMap 과 ConcurrentLinkedQueue 이다.
    - 8-1. ConcurrentHashMap
      - 부분(segment) 잠금을 사용하여 컬렉션의 10개 요소가 저장되어 있을 경우 1개를 처리할 동안 처리하는 요소가 포함된 부분만 잠금하고 다른 부분은 스레드가 변경할 수 있도록 한다.
    - 8-2. ConcurrentLinkedQueue
      - 락 프리 알고리즘을 구현하여 여러 개의 스레드가 동시에 접근할 경우, 잠금을 사용하지 않고도 최소한 하나의 스레드가 안전하게 요소를 저장하거나 얻도록 한다.