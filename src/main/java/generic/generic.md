#제네릭(Generic)

------------
1. 제네릭을 사용해야 하는 이유
    - 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있음
    - 불필요한 타입 변환(casting) 을 제거함

------------
2. 제네릭 메소드
   - 리턴 타입 앞에 <> 기호를 추가하고 타입 파라미터를 기술한 다음, 리턴 타입과 매개 타입으로 타입 파라미터를 사용
   ```java
   public <타입파라미터> 리턴타입 메소드명(매개변수...){}
   public <T> Box<T> boxing(T t){}
   
   //호출 시에는 다음과 같은 두 가지 방법으로 호출 가능하다
   리턴타입 변수 = <구체적 타입> 메소드명(매개값); // 명시적으로 구체적 타입을 지정
   리턴타입 변수 = 메소드명(매개값); // 매개값을 보고 구체적 타입을 추정
   
   Box<Integer> box = <Integer>boxing(100);
   Box<Integer> box = boxing(100);
   ```

------------
3. 제한된 타입 파라미터(<T extends 최상위타입>)
   - 타입 파라미터에 지정되는 구체적인 타입을 제한할 필요가 종종 있다.
   - 제한된 타입 파라미터를 선언하려면 타입 파라미터 뒤에 extends 키워드를 붙이고 상위 타입을 명시하면 된다.
   - 상위 타입은 클래스뿐만 아니라 인터페이스도 가능하다. 
      - cf) 인터페이스라고 해서 implements를 사용하지 않는다.
   ```java
   public <T extends 상위타입> 리턴타입 메소드명(매개변수...){}
   ```
   - 타입 파라미터에 지정되는 구체적인 타입은 상위 타입이거나 상위 타입의 하위 또는 구현 클래스만 가능하다.
   - 메소드의 중괄호 안에서 타입 파라미터 변수로 사용 가능한 것은 상위 타입의 멤버(필드, 메소드)로 제한된다.
   
---
4. 와일드카드 타입(<?>, <? extends ...>, <? super ...>)
   - ? 를 코드에서는 일반적으로 와이들카드라고 부른다.
   - 제네릭타입<?> : Unbounded Wildcards(제한없음)
      - 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.
   - 제네릭타입<? extends 상위타입> : Upper Bounded Wildcards(상위 클래스 제한)
      - 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 하위 타입만 올 수 있다.
   - 제네릭타입<? supper 하위타입> : Lower Bounded Wildcards(하위 클래스 제한)
      - 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 상위 타입이 올 수 있다.

---
5. 제네릭 타입과 상속 구현
   - 제네릭 타입도 다른 타입과 마찬가지로 부모 클래스가 될 수 있다.