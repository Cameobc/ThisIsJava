#중첩 클래스와 중첩 인터페이스(Nested Class & Interface)

------------
1. 중첩클래스와 중첩 인터페이스란?
   - 클래스가 여러 클래스와 관계를 맺는 경우는 독립적으로 선언하는 것이 좋으나, 특정 클래스와 관계를 맺을 경우에는 관계 클래스를 클래스 내부에 선언하는 것이 좋다.
   - 중첩 클래스(Nested Class)란 클래스 내부에 선언한 클래스를 말하며, 중첩 클래스를 사용하면 두 클래스의 멤버들이 서로 쉽게 접근할 수 있으며, 외부에 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다.
   - 중첩 인터페이스를 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위함이다.
------------
2. 중첩 클래스
   - 클래스 내부에 선언되는 위치에 따라 두 가지로 분류된다. 

|선언 위치에 따른 분류| |선언위치|설명|
|---|---|---|---|
|멤버 클래스|인스턴스 멤버 클래스|class A{ class B{}}| A 객체를 생성해야만 사용할 수 있는 B 중첩 클래스|
|멤버 클래스|정적 멤버 클래스|class A{ static class B{}}| A 클래스로 바로 접근할 수 있는 B 중첩 클래스|
|로컬 클래스| |class A{ void method(){ class B{}}}| method()가 실행될 때만 사용할 수 있는 B 중첩 클래스|
   - 멤버 클래스도 하나의 클래스이기 때문에 컴파일 하면 바이트 코드 파일(.class)이 별도로 생성된다.
   - <u>A</u>(바깥클래스) $ <u>B</u>(멤버클래스) .class
   - 로컬 클래스   
   - <u>A</u>(바깥클래스) $1 <u>B</u>(로컬클래스) .class
   - <u>**인스턴스 멤버 클래스**</u>는 static 키워드 없이 선언된 클래스를 의미하며 인스턴스 필드와 메소드만 선언 가능하며, 바깥 클래스의 모든 필드와 모든 메소드 접근 가능
   - <u>**정적 멤버 클래스**</u>는 static 키워드로 선언된 클래스를 의미하며 모든 종류의 필드와 메소드 선언 가능하며, 바깥 클래스의 정적 필도와 메소드에만 접근 가능
   - <u>**로컬 클래스**</u>는 중첩 메소드 내에서도 선언 가능하며, 접근 제한자 및 static 를 붙일 수 없다. 메소드 내부에서만 사용하고, 인스턴스 필드와 메소드만 선언 가능하며, this 키워드를 사용하면 바깥 클래스가 아니라 중첩 클래스의 필드와 메소드가 사용되기 때문에 바깥 클래스의 이름을 this 앞에 붙여서 사용한다. 메소드가 실행될 때 메소드 내에서 객체를 생성하고 사용하며 비동기 처리를 위해 스레드 객체를 만들 때 주로 사용한다.

------------
3. 로컬 클래스에서의 사용 제한
   - 로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한 없이 사용 가능하나, 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 경우 문제가 있을 수 있다.
   - 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재하여 계속 사용될 수 있으나, 매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라지기 때문에 로컬 객체에서 사용할 경우 문제가 발생한다.
   - 이 문제를 해결하기 위해 로컬 클래스 내부에 로컬 클래스에서 사용하는 매개 변수나 로컬 변수를 복사해 주고 사용하며, 매개변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해 둔 값과 달라지는 문제를 해결하기 위해 매개 변수나 로컬 변수를 final 로 선언해서 수정을 막는다.
   - 즉, 로컬 클래스에서 사용 가능한 것은 final 로 선언된 매개 변수와 로컬 변수 뿐이다.
   - final 키워드의 존재 여부 차이점은 로컬 클래스의 복사 위치로, final 키워드가 있다면 로컬 클래스의 메소드 내부에 지역 변수로복사되지만, final 키워드가 없다면 로컬 클래스의 필드로 복사된다.
   - 로컬 변수와 매개 변수 모두 final 특성을 갖는다는 것을 알면 되며, 자바 8부터는 붙이지 않아도 final 특성을 지니고 있음에 주목해야 한다.
------------
4. 익명 객체
   - 익명 객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. 필드의 초기값이나 로컬 변수의 초기값, 매개 겹ㄴ수의 매개값으로 주로 대입되며, 스레드 객체를 간편하게 생성할 목적으로 많이 활용된다.
     
   1. 익명 자식 객체 생성
      - 자식 클래스가 재사용되지 않고, 오로지 해당 필드와 변수의 초기값으로만 사용할 경우라면 익명 자식 객체를 생성해서 초기값으로 대입하는 것이 좋다.
      - 하나의 실행문이므로 끝에는 세미콜론을 반드시 붙여야 한다.
      - 메소드의 매개 변수가 부모 타입일 겨웅 메소드 호출 코드에서 익명 자식 객체를 생성해서 매개값으로 대입할 수도 있음.
      - 익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명 자식 객체 내부에서만 사용되고, 외부에서는 필드와 메소드에 접근할 수 없다. 부모 타입에 선언된 것만 사용 가능하기 때문이다.
   ```java
      부모클래스 [필드|변수] = new 부모클래스(매개값){
        //필드
        //메소드
      }    
   ```
   ```java
      class A{
        Parent field = new Parent(){
            // a 클래스의 필드 선언
            int childField;
            void childMethod(){}
            // Parent의 메소드 오버라이딩
            @Override
            void parentmethod(){}
        };    
      }
   ```
      ```java
      class A{
        void method(){
            // 로컬 변수 선언
            int childField;
            void childMethod(){}
            //Parent 의 메소드 오버라이딩
            @Override
            void parentMethod(){}
        };    
      }
   ```

   