#인터페이스(Interface)

------------
1. 역할
   - 객체의 사용 방법을 정의한 타입으로 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 함
   - 자바 8의 람다식은 함수적 인터페이스의 구현 객체를 생성하기 때문에 인터페이스의 중요성이 더욱 커짐
   - 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 하며, 개발 코드는 객체의 내부 국조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다.
    > 왜 중간에 인터페이스를 두는가?
     > - 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서임
     > - 인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로, 어떤 객체를 사용하는냐에 따라 실행 내용과 리턴값이 다를 수 있다. 따라서, 개발 코드 측면에서는 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다는 장점을 지니게 된다.

------------
2. 인터페이스 선언
   - 물리적 형태는 클래스와 동일하나, 소스를 작성할 때 선언하는 방법이 다름
      > class 키워드 대신 interface 키워드 사용
   - 클래스는 필드, 생성자, 메소드를 구성 멤버로 지니지만, 인터페이스는 상수와 메소드만을 구성 멤버로 지닌다. 또한 객체로 생성할 수 없기 때문에 생성자를 가질 수 없다.
   - 자바 8 이후로는 디폴트 메소드와 정적 메소드 선언이 가능해졌다.
   ```java
   interface 인터페이스명{
        // 상수
        타입 상수명 = 값;
        //추상 메소드
        타입 메소드명(매개변수...);
        //default 메소드
        default 타입 메소드명(매개변수...){};
        //정적 메소드
        static 타입 메소드명(매개변수...){};
   }
   ```
   > - 상수 필드(Constant Filed)
   >  - 인터페이스는 객체 사용 설명서이므로 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없지만 상수 필드는 선언 가능함
   >  - 상수는 인터페이스에 고정된 값으로 런타임 시에 데이터를 바꿀 수 없으며, 선언시 반드시 초기값을 대입해야 함.
   >  - 인터페이스에서 선언한 필드는 모두 public static final 을 지니며, 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
   > - 추상 메소드(Abstract Method)
   >  - 객체가 가지고 있는 메소드를 설명한 것으로 호출 시 어떤 매개값이 필요하고, 리턴 타입이 무엇인지만 알려줌
   >  - 실제 실행부는 구현 객체가 지니고 있다.
   >  - 모두 public abstract 의 특성을 갖기 때문에 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
   > - 디폴트 메소드(Default Method)
   >  - 인터페이스에 선언되지만 사실은 객체(구현 객체)가 가지고 있는 인스턴스 메소드
   >  - 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해 자바 8에서 허용
   >  - 형태는 인스턴스 메소드와 동일한데, default 키워드가 리턴 타입 앞에 붙는다.
   >  - public 특성을 갖기 때문에 생략해도, 자동적으로 컴파일 과정에서 추가된다.
   >  - 구현 객체가 있어야 사용가능하다. 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드라고 생각하면 되며, 오버라이딩해서 사용 가능하다.
   > - 정적 메소드(Static Method)
   >  - 자바 8에서 부터 작성가능하며, 디폴트 메소드와는 달리 객체가 없어도 인터페이스만으로 호출이 가능함
   >  - 클래스의 정적 메소드와 완전 동일함
   >  - public 특성을 갖기 때문에 public 을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다. 
   >  - 정적 메소드는 바로 호출 가능하다.
   - 인터페이스의 모든 메서드는 기본적으로 public 접근 제한을 갖기 때문에 public 보다 더 낮은 접근 제헌으로 작성할 수 없다.
   - 실체 메소드를 구현 클래스가 작성하지 않으면 구현 클래스는 자동적으로 추상 클래스가 된다. 그렇기 때문에 선언부에 abstract 를 추가해야 한다.
   - 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입될 경우 구현 객체의 번지를 저장한다.
------------
3. 익명 구현 객체
   - 자바는 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법을 제공하는데, 그것이 익명 구현 객체이다.
   - UI 프로그래밍에서 이벤트를 처리하기 위해, 임시 작업 스레드를 만들기 위해 익명 구현 객체를 많이 활용함
   - 자바 8에서 지원하는 람다식은 인터페이스의 익명 구현 객체를 만든다.
   > 주의점!
   > - 하나의 실행문이므로 끝에는 세미콜론을 반드시 붙여야 함
   ``` java
      인터페이스 변수 = new 인터페이스(){
         // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언  
         // 인터페이스 안에 선언된 모든 추상 메소드들의 실체 메소드를 작성하지 않으면 컴파일 에러 발생
         // 추가적으로 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용가능하며 인터페이스 변수로 접근 불가
      };
   ```
   - 모든 객체는 클래스로부터 생성되며, 익명 구현 객체도 예외는 아니다.
   > - RemoteControlExample.java 를 컴파일하면 자바 컴파일러에 의해 자동으로 다음과 같은 클래스 파일(RemoteControlExample$1.class) 이 만들어진다.
   > - 이름 뒤에 $ 가 붙고 생성 번호가 붙으며 생성 번호는 1부터 시작한다.
------------
4. 타입 변환과 다형성
   - 요즘은 상속보다는 인터페이스를 통해 다형성을 구현하는 경우가 많다
   - 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질을 말함
   - 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스는 만드는 기술이라는 개념적 차이가 존재하지만 둘 다 다형성을 구현하는 기술임
   - 인터페이스 타입으로 매개 변수를 선언하면 메소드 호출 시 매개값으로 여러 구현 객체를 줄 수 있기 때문에 메소드 실행 결과가 다양해짐. 그렇기 때문에 인터페이스는 메소드의 매개변수로 많이 등장한다.
   - 구현 객체가 인터페이스 타입으로 변환되는 것을 자동 타입변환(Promotion)이라 하며, 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환시킬 수 있다.
   - 자동 타입 변환을 통해 필드와 매개 변수의 다형성을 구현할 수 있다.
   - instanceof 연산자를 통해 매개값을 확인 후 안전하게 강제 타입 변환을 진행해야 함
------------
5. 인터페이스 상속
   - 다중 상속을 허용하며, extends 키워드 뒤에 상속할 인터페이스들을 나열함
   - 하위 인터페이스로 타입 변환되면 상/하위 인터페이스의 모든 메소드 사용 가능
   - 상위 인터페이스로 타입 변환되면 하위 인터페이스의 메소드 사용 불가능
------------
6. 디폴트 메소드와 인터페이스 확장
   - 디폴트 메소드는 모든 구현 객체에서 공유하는 기본 메소드처럼 보이지만 사실 인터페이스에서 디폴트 메소드를 허용한 다른 이유가 있음
   - 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해 디폴트 케모드 허용
   - 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 개발한 구현 클래스를 그대로 사용할 수 있으며, 새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다.
   - 디폴트 메소드는 추상 메소드가 아니기 때문에 구현 클래스에 실체 메소드를 작성할 필요가 없음
   > - 디폴트 메소드가 있는 인터페이스의 상속
   > 1. 디폴트 메소드를 단순히 상속받는다
   > 2. 디폵트 메소드를 재정의하여 실행내용을 변경한다
   > 3. 디폴트 메소드를 추상 메소드를 재선언한다.
